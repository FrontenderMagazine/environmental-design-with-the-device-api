# Дизайн, учитывающий окружающий мир, с помощью Device API

![Иллюстрация](img/header.jpg?raw=true&repo=environmental-design-with-the-device-api "Иллюстрация")

Если вы когда-нибудь стояли на стуле и держали сотовый телефон на вытянутой к
потолку руке, чтобы сигнал был получше, — или обновляли страницу, которая
зависла на 30 секунд, то вы уже знаете что в опыте взаимодействия пользователя
с устройствами есть серьезные проблемы. Мы тратим тысячи часов, разрабатывая
интерфейсы в результате бесконечных разговоров, тестов на пользователях и
статистических данных, в которых мы тонем с (виртуальной) головой, и потом все
ощущение пользователя от нашего интерфейса идет насмарку из-за скверного
сигнала от вышки сотовой связи.

Может быть, ваш пользователь переключился с 3G на WiFi. Может быть, у него
садится батарейка. Может быть, вокруг него темно. Что бы ни произошло, факторы
реальной жизни легко могут нарушить все ваши самые благие намерения — и добавить
вашим пользователям фрустрации и гнева.

Мысль, что во время планирования нужно принимать во внимание факторы реального
мира вокруг нас, [не нова][1]. Дизайн, учитывающий окружающий мир, появляется
как минимум в 500 г. до н.э., когда древние греки начали строить дома,
отапливаемые солнечной энергией, и этот дизайн покоится на двух простых
истинах: реальный мир существует, и вы не можете его контролировать.

Конечно, вы не можете контролировать все факторы, когда пользователь работает с
вашим дизайном, но вы определенно можете учитывать их, по крайней мере признав,
что эти факторы имеют место. Я называю это условиями дизайна. Некоторые условия
дизайна — например, какое устройство использует пользователь — остаются одними и
теми же на протяжении единичного посещения или взаимодействия с вашим продуктом.
Но у других условий — например, потребление энергии, освещение, мощность сигнала
— есть возможность (а иногда — и тенденция) меняться на протяжении одного
посещения или даже при переходе от одной страницы к другой.

Всего лишь год назад у меня не было бы определенного решения этих проблем в
интерфейсах для пользователей, поскольку нужные для этого API на уровне
устройств еще не были готовы для запуска. Но сейчас мы можем начать делать
что-то, чтобы улучшить ощущения наших пользователей даже в этих меняющихся
условиях, благодаря последним разработкам [Device API][1].

## Что такое Device API?

Device API начала разрабатываться в июле 2011 г., когда Mozilla и доктор Андреас
Галь (Andreas Gal) создали [Boot2Gecko][3], операционную систему, полностью
построенную на веб-технологиях. Интересным в этой ОС было то, что Mozilla также
разрабатывала  JavaScript-API, которые позволяли браузеру иметь доступ к
функциям на уровне устройства.

Некоторые из этих API остались внутри операционной системы Boot2Gecko, но
большая часть проделанной работы была передана в W3C для стандартизации. На этой
работе мы и сфокусируемся сегодня: мы исследуем эти API и тот потенциал, который
они имеют для того, чтобы улучшить то, как наши продукты ведут себя в реальном
мире и в разных состояниях окружающего мира, важных для дизайна.

## Состояние батареи и информация о сети

Отзывчивый дизайн сэкономил нам много нервов. Но также с принятием этой
парадигмы на первый план вышли новые занимательные задачи: например, управление
ресурсами. Что мы будем делать с изображениями, чтобы они масштабировались
правильно в любых условиях: на маленьких экранах или в условиях медленного
соединения?

Если бы проблема состояла только в том, что «на маленьких экранах надо выводить
маленькие изображения», тогда вся [проблема изображений в отзывчивом дизайне][4]
решалась бы [элементом *picture*][5]. Но предполагается также, что на
маленький экран мы должны передать маленькое изображение, чтобы
соответствовать его размеру и возможному ограничению скорости соединения.
Однако мы начинаем понимать, что размер экрана имеет довольно-таки мало
отношения к скорости сети.

При идеальных условиях у всех пользователей молниеносной скорости соединение и
полностью заряженная батарея. Но чем больше людей используют мобильные
устройства, тем менее вероятным это становятся, и тем чаще эти условия будут
влиять на ощущения пользователя от вашего продукта. Если пользователь кликает по
страницам на быстром соединении, то изображения с маленьким разрешением он
воспримет как плохой дизайн. С другой стороны, если у пользователя плохое
соединения и батарея на нуле, то, пока он будет скачивать огромные изображения,
телефон может и вовсе умереть.

Именно в таких ситуациях [Battery Status API][6] и [The Network Information API][7]
становятся особенно интересными.

Battery Status API рассказывает вам, сколько осталось заряда батареи в
устройстве (level), становится ли уровень заряда меньше (discharging) или больше
(charging). Эта информация приводится не только как переменные во время
загрузки, но еще и через события, привязанные к статусу батареи. События,
которые сейчас включены в спецификацию, выглядят так: `onchargingchange`,
`onchargingtimechange`, `ondischargingtimechange` и `onlevelchange`.

Все это становится еще интереснее, когда используется в паре с Network
Information API, которая позволяет вам узнать информацию о скорости соединения
устройства с интернетом. В текущей версии спецификации устройство возвращает два
значения: скорость соединения в мегабайтах в секунду и булеву переменную, с
помощью которой вы можете узнать, ограничивается ли скорость соединения
каким-либо образом провайдером. Вот и вся информация, которая нужна вам для
того, чтобы фильтровать ресурсы и разбираться со скоростью соединения в
браузере. Чтобы отслеживать, когда пользователь теряет соединение, API
возвращает в качестве значения скорости `0`.

Хотя информация о сети и состояние батареи чудесно работают сами по себе,
комбинация этих двух API дает вам возможность не только управлять ресурсами во
время загрузки страницы, но и изменять интерфейс по мере того, как изменяется
скорость соединения или заряд батареи. Вы можете даже проводить маленькие
энергетические тесты, сколько времени батарея еще продержится при этих условиях
(как «сколько километров вы проедете, пока не кончится бензин» в машине). У вас
не получится выдать какую-то конкретную информацию («Facebook выедает вашу
батарейку»), но по крайней мере вы будете знать, достаточно ли заряда для того,
чтобы закончить какую-нибудь задачу в вашем приложении.

Эти две API (а особенно их комбинация), скорее всего, должны стать нашей первой
возможностью делать дизайны лучше приспособленными для реальных жизненных
ситуаций. Они позволяют нам определять «бутылочные горлышки» производительности
и создавать интерфейс, который обходит их (пример: наша задача с управлением
изображениями). Но есть и несколько других API, которые выдаются среди остальных
— это API датчика освещения и датчика приближения, которые выносят дизайн чуть
дальше за пределы браузера.

## Датчик освещения

[Ambient Light Sensor API][8] использует датчик освещения устройства, чтобы оно
рассказало нам о своих текущих условиях освещения. Конечно, ограничение этого
API состоит в том, что у устройства должен быть [датчик освещения][9] — встроен он в
камеру или в какой-либо другой датчик. Неважно, где этот датчик находится, но он
должен наличествовать. API работает примерно так же, как API состояния батареи,
то есть уровень света можно получить во время первоначальной загрузки и с
помощью события `ondevicelight`.

Это API может показаться немножко странным, поскольку в нем не используется
привычная вебу система единиц — пиксель, проценты или `em`; API возвращает
значения в люксах (`lx`). Люкс - международная единица измерения мощности света —
в общем, не совсем то, что мы используем в вебе каждый день. Я вот, например, ни
разу и не слышал о такой единице, пока не стал заниматься этим API, но зато я
чувствую себя реально умным, вставляя фразу о ней в какой-нибудь диалог.
Поскольку это применяется только в самых современных устройствах, поддержка
люксов на уровне устройства несколько непредсказуема.

Ambient Light Sensor API наверняка улучшит ощущения от использования электронной
книги — вроде Kindle, поскольку та предоставляет доступ к информации об уровне
освещенности в помещении. Обладая этой информацией, вы можете легко настроить
значения цветов, типографику и другие элементы дизайна, чтобы обеспечить
пользователям более удобный интерфейс для чтения.

## Датчик приближения

[Proximity Sensor API][10], которая дает браузеру возможность коммуникации ближнего
поля (NFC), скорее всего, сегодня находится дальше всего от нас в плане
возможностей использования: не из-за плохой спецификации, а потому что у
большинства устройством еще нет необходимых датчиков. Лишь в относительно малое
число смартфонов прямо сейчас встроена NFC-технология, и понадобится наверняка
еще несколько итераций, пока мы не увидим ее в чем-нибудь вроде iPhone.

Если устройство пользователя содержит датчик приближения, вы можете
воспользоваться им, чтобы обнаружить предметы в близкой зоне, которые отдают
NFC-информацию (круто, не правда ли?). В API включено событие `ondeviceproximity`,
которое вызывается, когда предмет оказывается в радиусе датчика.

W3C не рекомендует пытаться точно измерить расстояние до предмета из-за
непостоянства текущих датчиков. Но вы тем не менее можете еще дальше расширить
границы пользовательского интерфейса: всего несколькими строчками вы можете
вырваться из узкого пространства браузера и вставить в интерфейс огромный
настоящий мир интерактивных предметов, светочувствительности, информации о
соединении и потреблении энергии.

## Как развивать дизайн, учитывающий окружающий мир?

Дизайн, учитывающий окружающий мир — это просто концепт, в котором мы начинаем
принимать во внимание внешние факторы. Появление Device API это только первый шаг.

Каждый день появляются новые API, которые можно творчески использовать в своих
приложениях, но не стоит ограничиваться ими. Мы уже знаем, что опыт
использования приложения в разных браузерах может отличаться, но я бы сказал,
что он может быть разным и в каждой комнате вашего дома. С изменением скорости
соединения, заряда батареи и других условий может изменяться и поведение
вашего приложения.

Разбираться с хаосом внутри браузеров для большинства из нас — постоянная
работа, и поэтому у нас есть тестирование и контроль качества. Ключ к развитию
веба и созданию хороших интерфейсов — принять этот хаос, а не тратить время,
борясь с ним. Оберните безумие в свою пользу и постоянно добавляйте новые
инструменты в свою коробочку инструментов проектировщика интерфейсов: если все
мы будем делать так, мы поможем веб-технологиям двигаться в правильном
направлении.

[1]: http://en.wikipedia.org/wiki/Environmental_design "Дизайн, учитывающий окружающий мир"
[2]: http://dev.w3.org/2009/dap/ "Device API"
[3]: http://www.wired.com/gadgetlab/2012/05/hands-on-with-boot2gecko-the-mobile-os-built-entirely-on-web-standards/ "Boot2Gecko"
[4]: http://alistapart.com/article/responsive-images-how-they-almost-worked-and-what-we-need#Responsive%20Images:%20How%20They%20Almost%20Worked%20and%20What%20We%20Need "Проблема изображений в отзывчивом дизайне"
[5]: http://www.w3.org/community/respimg/2012/03/15/polyfilling-picture-without-the-overhead/ "Элементом picture"
[6]: http://www.w3.org/TR/battery-status/ "Battery Status API"
[7]: http://www.w3.org/TR/netinfo-api/ "The Network Information API"
[8]: http://www.w3.org/TR/ambient-light/ "Ambient Light Sensor API"
[9]: http://lists.w3.org/Archives/Public/public-device-apis/2012Aug/0084.html "Датчик освещения"
[10]: http://www.w3.org/TR/2012/WD-proximity-20120712/ "Proximity Sensor API"